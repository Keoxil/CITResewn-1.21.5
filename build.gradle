plugins.apply 'fabric-loom'
plugins.apply 'io.shcm.shsupercm.fabric.fletchingtable'

version = "${property('mod.version')}+${stonecutter.current.version}"
group = 'shcm.shsupercm.fabric.citresewn'

repositories {
    maven { url 'https://maven.terraformersmc.com/releases/' }
    maven { url 'https://maven.shedaniel.me/' }
}

dependencies {
    minecraft "com.mojang:minecraft:${stonecutter.current.version}"
    mappings "net.fabricmc:yarn:${property('deps.yarn')}:v2"

    modCompileOnly "net.fabricmc:fabric-loader:${property('deps.fabric-loader')}"
    modCompileOnly "net.fabricmc.fabric-api:fabric-api:${property('deps.fabric-api')}"

    modCompileOnly "com.terraformersmc:modmenu:${property('deps.modmenu')}"
    modCompileOnly "me.shedaniel.cloth:cloth-config-fabric:${property('deps.cloth-config')}"

    include stonecutter.node.sibling("defaults").project
}

fletchingTable {
    defaultMixinEnvironment = "auto"
}

loom {
    accessWidenerPath = file("../../src/main/resources/citresewn.accesswidener")

    runConfigs.client.ideConfigGenerated = false
    runConfigs.server.ideConfigGenerated = false
}

java {
    withSourcesJar()
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
    archivesBaseName = property('mod.jarname')
}

tasks.withType(JavaCompile).configureEach {
    options.release.set(17)
}

processResources {
    inputs.property 'mod_version', version
    inputs.property 'mod_target_mc', project.property('mod.target-mc')

    filesMatching('fabric.mod.json') {
        expand 'mod_version': version, 'mod_target_mc': project.property('mod.target-mc')
    }
}

jar {
    archiveClassifier.set 'dev'

    from rootProject.file('LICENSE')
}

if (stonecutter.current.isActive) {
    rootProject.tasks.register('buildActive') {
        group = 'project'

        dependsOn tasks.named('build')
    }

    plugins.apply 'com.modrinth.minotaur'
    plugins.apply 'com.matthewprenger.cursegradle'

    modrinth {
        token = TOKEN_MODRINTH
        projectId = property('publish.modrinth.id')
        uploadFile = remapJar
        changelog = java.nio.file.Files.readString(rootProject.file("Changelog.md").toPath())
        versionNumber = version
        versionName = "v" + version
        versionType = 'beta'
        additionalFiles = [sourcesJar.outputs.getFiles().singleFile]
        gameVersions = Arrays.asList(property('publish.target-mc').split(","))
    }

    curseforge {
        apiKey = TOKEN_CURSEFORGE
        project {
            id = property('publish.curseforge.id')
            changelogType = 'markdown'
            changelog = rootProject.file('Changelog.md')
            releaseType = 'beta'
            mainArtifact(remapJar) {
                displayName = "v" + version
            }
            addGameVersion 'Fabric'
            for (String version : property('publish.target-mc').split(","))
                addGameVersion version
        }
        options {
            forgeGradleIntegration = false
        }
    }

    rootProject.tasks.register('publishActive') {
        group = 'project'

        if (gradle.startParameter.taskNames.contains(it.name)) {
            System.out.println("Type the task name to confirm (${it.name}): ")
            try (BufferedReader input = new BufferedReader(new InputStreamReader(System.in))) {
                if (input.readLine() != it.name)
                    throw new GradleException('Task cancelled by user')
            }
        }

        TaskProvider<Task> remapJarTask = tasks.named('remapJar')
        TaskProvider<Task> curseforgeTask = tasks.named('curseforge')
        TaskProvider<Task> modrinthTask = tasks.named('modrinth')

        dependsOn remapJarTask, curseforgeTask, modrinthTask
        curseforgeTask.configure { mustRunAfter remapJarTask }
        modrinthTask.configure { mustRunAfter remapJarTask }
    }
}
